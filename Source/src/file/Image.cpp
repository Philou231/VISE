#include "file/Image.h"
#include <filesystem>
#include <iostream>
#include <cmath>
#include <SDL_image.h>
#include "misc/Utilities.h"

using namespace std;
namespace fs = std::filesystem;


int Image::m_graphicsCard_maxW=0;
int Image::m_graphicsCard_maxH=0;


Image::Image(SDL_Renderer* renderer, string path) :
    File(FILE_IMAGE),
    m_renderer(renderer),
    m_width(0),
    m_height(0),
    m_textureAll(NULL)
{
    if(m_graphicsCard_maxW==0 || m_graphicsCard_maxH==0)
    {
        SDL_RendererInfo infoRenderer;
        SDL_GetRendererInfo(renderer,&infoRenderer);

        m_graphicsCard_maxW = infoRenderer.max_texture_width;
        m_graphicsCard_maxH = infoRenderer.max_texture_height;
    }

    Image::createFile(path);
}

int Image::getW()
{
    return m_width;
}

int Image::getOriginalW()
{
    return float(m_width)*m_scaling;
}

int Image::getH()
{
    return m_height;
}

int Image::getOriginalH()
{
    return float(m_height)*m_scaling;
}

SDL_Rect Image::getSize()
{
    SDL_Rect rectSize;
    rectSize.x = 0;
    rectSize.y = 0;
    rectSize.w = m_width;
    rectSize.h = m_height;

    return rectSize;
}

int Image::createFile(string path)
{
    SDL_ClearError();

    SDL_Surface* image=NULL;
    try
    {
        m_path = fs::u8path(path).u8string();
        image = IMG_Load(m_path.c_str()); //Try the UTF8 encoding (the format outputed by VISE)
    }
    catch(std::exception &e)
    {
        cout <<"A path in non-UTF8 format is used (Most likely generated by Excel)" <<endl;
        m_path = fs::path(path).u8string();
        image = IMG_Load(m_path.c_str()); //Try the default page code encoding (the format outputed by Excel)
    }

    if(image==NULL) //Wrong path, not an image or error in the library
    {
        cout <<"There was an error while loading the image into RAM." <<endl;
        cout <<"The path used is this: " <<m_path <<endl;
        cout <<"The graphics library's error text mentions \"" <<SDL_GetError() <<"\"" <<endl;

        return 1;
    }

    m_width = image->w;
    m_height = image->h;

    cout <<"The image is correctly loaded into RAM with dimensions " <<m_width <<"x" <<m_height <<endl;

    if(m_textureAll!=NULL)
    {
        SDL_DestroyTexture(m_textureAll);
        m_textureAll = NULL;
    }

    //Setting texture of all the image
    if(m_width>m_graphicsCard_maxW || m_height>m_graphicsCard_maxH)
    {
        cout <<"Image is larger than the graphics card's max texture size of " <<m_graphicsCard_maxW <<"x" <<m_graphicsCard_maxH <<". Downsizing to fit the GPU." <<endl;
        if(m_graphicsCard_maxW*m_height/m_width < m_graphicsCard_maxH)
        {
            m_scaling = float(m_width) / float(m_graphicsCard_maxW);

            m_height=m_graphicsCard_maxW*m_height/m_width;
            m_width=m_graphicsCard_maxW;
        }
        else
        {
            m_scaling = float(m_height) / float(m_graphicsCard_maxH);

            m_width=m_graphicsCard_maxH*m_width/m_height;
            m_height=m_graphicsCard_maxH;
        }
        cout <<"Scaling: " <<m_scaling <<endl;

        cout <<"The scaled down image will have dimensions " <<m_width <<"x" <<m_height <<endl;
        SDL_ClearError();
        SDL_Surface* imageSmall=SDL_CreateRGBSurface(0,m_width,m_height,32,0,0,0,0);
        if(imageSmall==NULL)
        {
            cout <<"The scaled down image could not be create." <<endl;
            cout <<"The graphics library's error text mentions \"" <<SDL_GetError() <<"\"" <<endl;
        }
        SDL_BlitScaled(image, NULL, imageSmall, NULL);
        cout <<"After scaling the graphics library's error text mentions \"" <<SDL_GetError() <<"\"" <<endl;

        emptyTextureViews();
        m_textureAll = SDL_CreateTextureFromSurface(m_renderer, imageSmall);
        cout <<"After importing image to GPU the graphics library's error text mentions \"" <<SDL_GetError() <<"\"" <<endl;

        SDL_FreeSurface(imageSmall);
    }
    else
    {
        m_scaling = 1.0;
        cout <<"Image is smaller than the graphics card's max texture size of " <<m_graphicsCard_maxW <<"x" <<m_graphicsCard_maxH <<". No downsizing used." <<endl;
        emptyTextureViews();
        m_textureAll = SDL_CreateTextureFromSurface(m_renderer, image);
    }

    SDL_FreeSurface(image);

    return 0;
}

bool Image::loaded()
{
    return m_width!=0 && m_height!=0;
}


void Image::setView(void* uid, SDL_Rect displayRect, SDL_Rect* windowRect)
{
    TextureView* textureView=getTextureView(uid);
    if(textureView==NULL)
        return;

    bool newView=false;
    if(textureView->widgetRect.w==0 || textureView->widgetRect.h==0)
    {
        newView=true;
        textureView->widgetRect = displayRect;
    }

    if(newView)
        resetView(uid);
    else if(windowRect!=NULL && (windowRect->w != textureView->windowRect.w || windowRect->h != textureView->windowRect.h)) //window resized, not just moved
        pan(uid, textureView->windowRect.x-windowRect->x, textureView->windowRect.y-windowRect->y);
    else if(displayRect.w != textureView->widgetRect.w || displayRect.h != textureView->widgetRect.h)
        pan(uid, textureView->widgetRect.x-displayRect.x, textureView->widgetRect.y-displayRect.y);


    textureView->widgetRect = displayRect;

    if(windowRect!=NULL)
        textureView->windowRect = *windowRect;
}

SDL_Texture* Image::getTexture(TextureView* textureView)
{
    if(textureView==NULL)
        return NULL;

    if(textureView->displayingCropped)
        return textureView->textureCropped;
    else
        return m_textureAll;
}

SDL_Texture* Image::getTexture(void* uid)
{
    TextureView* textureView=getTextureView(uid);
    return Image::getTexture(textureView);
}

SDL_Rect Image::getRect(void* uid)
{
    TextureView* textureView=getTextureView(uid);
    return textureView->rect;
}

void Image::getRects(void* uid, SDL_Rect* rectSrc, SDL_Rect* rectDst)
{
    TextureView* textureView=getTextureView(uid);

    SDL_Rect tempRectSrc, tempRectDst;

    int textureW, textureH;
    SDL_QueryTexture(Image::getTexture(textureView), NULL, NULL, &textureW, &textureH);

    tempRectSrc.w = textureView->widgetRect.w*textureW/textureView->rect.w;
    tempRectSrc.h = textureView->widgetRect.h*textureH/textureView->rect.h;
    tempRectSrc.x = -textureView->rect.x*textureW/textureView->rect.w;
    tempRectSrc.y = -textureView->rect.y*textureH/textureView->rect.h;

    tempRectDst.x = max(0,textureView->rect.x);
    tempRectDst.y = max(0,textureView->rect.y);
    tempRectDst.w = textureView->rect.w - max(0,-textureView->rect.x) - max(0,textureView->rect.x+textureView->rect.w-textureView->widgetRect.w);
    tempRectDst.h = textureView->rect.h - max(0,-textureView->rect.y) - max(0,textureView->rect.y+textureView->rect.h-textureView->widgetRect.h);

    if(rectSrc!=NULL)
        (*rectSrc) = tempRectSrc;
    if(rectDst!=NULL)
        (*rectDst) = tempRectDst;
}

SDL_Rect Image::getWindowRect(void* uid)
{
    TextureView* textureView=getTextureView(uid);

    SDL_Rect returnedRect;
    if(textureView != NULL)
        return textureView->windowRect;
    else
        return returnedRect;
}

void Image::setPos(void* uid, int x, int y)
{
    TextureView* textureView=getTextureView(uid);
    Image::setX(textureView, x);
    Image::setY(textureView, y);
}

void Image::setZoom(void* uid, SDL_Rect originalImageRect, SDL_Rect originalPos, SDL_Rect currentPos)
{
    TextureView* textureView=getTextureView(uid);

    float zoomFactor = exp(float(originalPos.y-currentPos.y)/100);

    originalPos.x -= textureView->widgetRect.x;
    originalPos.y -= textureView->widgetRect.y;

    Image::setW(textureView, originalImageRect.w*zoomFactor); //H is adjusted automatically to stay scaled
    Image::setX(textureView, originalPos.x-float(originalPos.x-originalImageRect.x)*textureView->rect.w/originalImageRect.w);
    Image::setY(textureView, originalPos.y-float(originalPos.y-originalImageRect.y)*textureView->rect.h/originalImageRect.h);

    //TODO: Implement mip-mapping and activate it here
}


SDL_Rect Image::posImageToWindow(TextureView* textureView, SDL_Rect rectImage)
{
    SDL_Rect rectViewer={0,0,0,0};

    if(textureView==NULL)
        return rectViewer;

    rectViewer.x = textureView->widgetRect.x + (float(rectImage.x)+0.5) * textureView->rect.w / (m_width*m_scaling) + textureView->rect.x;
    rectViewer.y = textureView->widgetRect.y + (float(rectImage.y)+0.5) * textureView->rect.h / (m_height*m_scaling) + textureView->rect.y;

    return rectViewer;
}

SDL_Rect Image::posWindowToImage(TextureView* textureView, SDL_Rect rectViewer)
{
    SDL_Rect rectImage={0,0,0,0};

    if(textureView==NULL)
        return rectImage;

    rectImage.x = floor(float(rectViewer.x - textureView->widgetRect.x - textureView->rect.x) * (m_width*m_scaling) / textureView->rect.w);
    rectImage.y = floor(float(rectViewer.y - textureView->widgetRect.y - textureView->rect.y) * (m_height*m_scaling) / textureView->rect.h);

    return rectImage;
}

SDL_Rect Image::posImageToViewer(TextureView* textureView, SDL_Rect rectImage)
{
    SDL_Rect rectViewer={0,0,0,0};

    if(textureView==NULL)
        return rectViewer;

    rectViewer.x = (float(rectImage.x)+0.5) * textureView->rect.w / (m_width*m_scaling) + textureView->rect.x;
    rectViewer.y = (float(rectImage.y)+0.5) * textureView->rect.h / (m_height*m_scaling) + textureView->rect.y;

    return rectViewer;
}

SDL_Rect Image::posViewerToImage(TextureView* textureView, SDL_Rect rectViewer)
{
    SDL_Rect rectImage={0,0,0,0};

    if(textureView==NULL)
        return rectImage;

    rectImage.x = floor(float(rectViewer.x - textureView->rect.x) * (m_width*m_scaling) / textureView->rect.w);
    rectImage.y = floor(float(rectViewer.y - textureView->rect.y) * (m_height*m_scaling) / textureView->rect.h);

    return rectImage;
}

SDL_Rect Image::coordImageToWindow(void* uid, SDL_Rect rectImage)
{
    SDL_Rect rectWindow={0,0,0,0};

    TextureView* textureView = Image::getTextureView(uid);

    if(textureView==NULL)
        return rectWindow;


    rectWindow = Image::posImageToWindow(textureView, rectImage);//Converts the X and Y

    SDL_Rect tempRect;
    tempRect.x = rectImage.x + rectImage.w - 1;
    tempRect.y = rectImage.y + rectImage.h - 1;

    tempRect = Image::posImageToWindow(textureView, tempRect);//Converts the W & H

    rectWindow.w = tempRect.x - rectWindow.x + 1;
    rectWindow.h = tempRect.y - rectWindow.y + 1;

    return rectWindow;
}

SDL_Rect Image::coordWindowToImage(void* uid, SDL_Rect rectWindow)
{
    SDL_Rect rectImage={0,0,0,0};

    TextureView* textureView = Image::getTextureView(uid);

    if(textureView==NULL)
        return rectImage;


    rectImage = Image::posWindowToImage(textureView, rectWindow);//Converts the X and Y

    SDL_Rect tempRect;
    tempRect.x = rectWindow.x + rectWindow.w - 1;
    tempRect.y = rectWindow.y + rectWindow.h - 1;

    tempRect = Image::posWindowToImage(textureView, tempRect);//Converts the W & H

    rectImage.w = tempRect.x - rectImage.x + 1;
    rectImage.h = tempRect.y - rectImage.y + 1;

    return rectImage;
}

SDL_Rect Image::coordImageToViewer(void* uid, SDL_Rect rectImage)
{
    SDL_Rect rectViewer={0,0,0,0};

    TextureView* textureView = Image::getTextureView(uid);

    if(textureView==NULL)
        return rectViewer;


    rectViewer = Image::posImageToViewer(textureView, rectImage);//Converts the X and Y

    SDL_Rect tempRect;
    tempRect.x = rectImage.x + rectImage.w - 1;
    tempRect.y = rectImage.y + rectImage.h - 1;

    tempRect = Image::posImageToViewer(textureView, tempRect);//Converts the W & H

    rectViewer.w = tempRect.x - rectViewer.x + 1;
    rectViewer.h = tempRect.y - rectViewer.y + 1;

    return rectViewer;
}

SDL_Rect Image::coordViewerToImage(void* uid, SDL_Rect rectViewer)
{
    SDL_Rect rectImage={0,0,0,0};

    TextureView* textureView = Image::getTextureView(uid);

    if(textureView==NULL)
        return rectImage;


    rectImage = Image::posViewerToImage(textureView, rectViewer);//Converts the X and Y

    SDL_Rect tempRect;
    tempRect.x = rectViewer.x + rectViewer.w - 1;
    tempRect.y = rectViewer.y + rectViewer.h - 1;

    tempRect = Image::posViewerToImage(textureView, tempRect);//Converts the W & H

    rectImage.w = tempRect.x - rectImage.x + 1;
    rectImage.h = tempRect.y - rectImage.y + 1;

    return rectImage;
}


void Image::resetView(void* uid)
{
    TextureView* textureView=getTextureView(uid);

    if(textureView->widgetRect.w*m_height/m_width < textureView->widgetRect.h)
    {
        textureView->rect.w=textureView->widgetRect.w;
        textureView->rect.h=textureView->widgetRect.w*m_height/m_width;
    }
    else
    {
        textureView->rect.w=textureView->widgetRect.h*m_width/m_height;
        textureView->rect.h=textureView->widgetRect.h;
    }

    textureView->rect.x=(textureView->widgetRect.w-textureView->rect.w)/2;
    textureView->rect.y=(textureView->widgetRect.h-textureView->rect.h)/2;

    textureView->displayingCropped=false;
}

void Image::showAll(void* uid)
{
    TextureView* textureView=getTextureView(uid);

    SDL_Rect oldRect = textureView->rect;

    if(textureView->widgetRect.w*Image::getImageH(textureView)/Image::getImageW(textureView) < textureView->widgetRect.h)
    {
        textureView->rect.w=textureView->widgetRect.w;
        textureView->rect.h=textureView->widgetRect.w*Image::getImageH(textureView)/Image::getImageW(textureView);
    }
    else
    {
        textureView->rect.w=textureView->widgetRect.h*Image::getImageW(textureView)/Image::getImageH(textureView);
        textureView->rect.h=textureView->widgetRect.h;
    }

    textureView->rect.x=round(textureView->widgetRect.w/2-float(textureView->widgetRect.w/2-textureView->rect.x)*textureView->rect.w/oldRect.w);
    textureView->rect.y=round(textureView->widgetRect.h/2-float(textureView->widgetRect.h/2-textureView->rect.y)*textureView->rect.h/oldRect.h);

    textureView->displayingCropped=false;
}

void Image::showPixelPerfect(void* uid)
{
    TextureView* textureView=getTextureView(uid);

    SDL_Rect oldRect = textureView->rect;

    textureView->rect.w=Image::getImageW(textureView);
    textureView->rect.h=Image::getImageH(textureView);
    textureView->rect.x=round(textureView->widgetRect.w/2-float(textureView->widgetRect.w/2-oldRect.x)*textureView->rect.w/oldRect.w);
    textureView->rect.y=round(textureView->widgetRect.h/2-float(textureView->widgetRect.h/2-oldRect.y)*textureView->rect.h/oldRect.h);
}

void Image::pan(void* uid, int x, int y)
{
    TextureView* textureView=getTextureView(uid);
    if(textureView==NULL)
        return;

    Image::setX(textureView, textureView->rect.x + x);
    Image::setY(textureView, textureView->rect.y + y);
}

void Image::zoom(void* uid, SDL_Rect cursorPos, int z)
{
    TextureView* textureView=getTextureView(uid);
    if(textureView==NULL)
        return;

    SDL_Rect newPos=cursorPos;
    newPos.y -= z;

    Image::setZoom(uid, textureView->rect, cursorPos, newPos);
}








void Image::setX(TextureView* textureView, int x)
{
    textureView->rect.x = x;

    if(textureView->rect.x > textureView->widgetRect.w/2)//Too far to the right
        textureView->rect.x = textureView->widgetRect.w/2;
    else if(textureView->rect.x + textureView->rect.w < textureView->widgetRect.w/2)//Too far to the left
        textureView->rect.x = textureView->widgetRect.w/2 - textureView->rect.w;
}

void Image::setY(TextureView* textureView, int y)
{
    textureView->rect.y = y;

    if(textureView->rect.y > textureView->widgetRect.h/2)//Too far to the bottom
        textureView->rect.y = textureView->widgetRect.h/2;
    else if(textureView->rect.y + textureView->rect.h < textureView->widgetRect.h/2)//Too far to the top
        textureView->rect.y = textureView->widgetRect.h/2 - textureView->rect.h;
}

void Image::setW(TextureView* textureView, int w)
{
    textureView->rect.w = w;
    textureView->rect.h = w*m_height/m_width;


    if(textureView->rect.w<textureView->widgetRect.w/2 && textureView->rect.h<textureView->widgetRect.h/2) //image too small
    {
        if(textureView->widgetRect.w*m_height/m_width < textureView->widgetRect.h)
        {
            textureView->rect.w=textureView->widgetRect.w/2;
            textureView->rect.h=textureView->widgetRect.w*m_height/m_width/2;
        }
        else
        {
            textureView->rect.w=textureView->widgetRect.h*m_width/m_height/2;
            textureView->rect.h=textureView->widgetRect.h/2;
        }
    }
    if(textureView->rect.w>10*m_width) //image too big
    {
        textureView->rect.w=10*m_width;
        textureView->rect.h=10*m_height;
    }
}

int Image::getImageW(TextureView* textureView)
{
    if(textureView->displayingCropped)
        return textureView->crop.w;
    else
        return m_width;
}

int Image::getImageH(TextureView* textureView)
{
    if(textureView->displayingCropped)
        return textureView->crop.h;
    else
        return m_height;
}

void Image::emptyTextureViews()
{
    for(int i=(int)m_textureViews.size()-1;i>=0;i--)
    {
        if(m_textureViews[i].textureCropped != NULL)
            SDL_DestroyTexture(m_textureViews[i].textureCropped);
        m_textureViews.erase(m_textureViews.begin()+i);
    }
}

TextureView* Image::getTextureView(void* uid)
{
    if(uid==NULL)
        return NULL;

    for(size_t i=0;i<m_textureViews.size();i++)
    {
        if(m_textureViews[i].UID==uid)
            return &(m_textureViews[i]);
    }

    //Not yet registered
    TextureView tempTextureView;
    tempTextureView.UID = uid;
    tempTextureView.displayingCropped = false;

    tempTextureView.windowRect = {0,0,0,0};
    tempTextureView.widgetRect = {0,0,0,0};
    tempTextureView.rect = {0,0,m_width,m_height};
    tempTextureView.crop = {0,0,0,0};
    tempTextureView.textureCropped = NULL;

    m_textureViews.push_back(tempTextureView);
    return &m_textureViews.back();
}



Image::~Image()
{
    emptyTextureViews();
    if(m_textureAll!=NULL)
        SDL_DestroyTexture(m_textureAll);
}
